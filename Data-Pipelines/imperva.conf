input {
    file {
            path => '/usr/share/logstash/logs/imperva.log'
            type => 'imperva'
            start_position => 'beginning'
            sincedb_path => "/dev/null"
   }
}
#####################################################################################

filter{

        ruby  { code  => '
              if event.get("message").nil?
                event.cancel
              else
                data = event.get("message")
                f =data
                f.split().each do |xx|
                  if xx !~ /cs\d/ && xx =~ /=/
                    #puts xx
                    if xx =~ /cat/
                      m=xx&.match(%r{cat=(?<x>.+)})
                      ans=m[:x]
                      event.set("[cef][cat]", ans)
                    end
                    if xx =~ /duser/
                      m=xx&.match(%r{duser=(?<x>.+)})
                      ans=m[:x]
                      event.set("[cef][duser]", ans)
                    end
                    if xx =~ /dst/
                      m=xx&.match(%r{dst=(?<x>.+)})
                      ans=m[:x]
                      event.set("[cef][dst]", ans)
                    end
                    if xx =~ /dpt/
                      m=xx&.match(%r{dpt=(?<x>.+)})
                      ans=m[:x]
                      event.set("[cef][dpt]", ans)
                    end
                    if xx =~ /src/
                      m=xx&.match(%r{src=(?<x>.+)spt})
                      ans=m[:x]
                      event.set("[cef][src]", ans)
                    end
                    if xx =~ /spt/
                      m=xx&.match(%r{spt=(?<x>.+)})
                      ans=m[:x]
                      event.set("[cef][spt]", ans)
                    end
                    if xx =~ /act/
                      m=xx&.match(%r{act=(?<x>.+)})
                      ans=m[:x]
                      event.set("[cef][act]", ans)
                    end
                    if xx =~ /proto/
                      m=xx&.match(%r{proto=(?<x>.+)})
                      ans=m[:x]
                      event.set("[cef][proto]", ans)
                    end
                  end
                end
                ################################################
                #=======================================================
                #THIS WILL TRY TO EXTRACT ALL CUSTOM FIELDS (SC) FROKM THE
                #NUMBERS LISTED IN NUMS
                nums=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
                nums.each do |txx|
                  tx=txx.to_s
                  if command = f&.match(%r{cs#{tx}=(?<c>.+)cs#{tx}})
                    key1="field_#{tx}"
                    if value=command[:c]
                    end
                    #this is for earlier cs fields
                    if label = f&.match(%r{cs#{tx}Label=(?<lbl>[\w\d\s]*)cs\d})
                      key2=label[:lbl]&.downcase
                      #ans="#{key1}_#{key2} = #{value}"
                      #puts ans
                      event.set("[#{key1}][#{key2}]", value)
                    else
                      #this is for the last cs field_
                      if label = f&.match(%r{cs#{tx}Label=(?<lbl>[\w\d\s]*)})
                        key2=label[:lbl]&.downcase
                        #ans="#{key1}_#{key2} = #{value}"
                        #puts ans
                        event.set("[#{key1}][#{key2}]", value)
                      end
                    end
                  end
                end
                #=======================================================
                #=======================================================
                #THIS IS THE TRADITIONAL CEF FIELDS LIKE DEVCIE, PRODUCT
                #AND VENDOR INFORMATIONS
                c=0
                f.split("|").each do |xx1|
                  c=c+1
                  if c == 1
                    #source ip
                    sip = xx1&.match(%r{(?<ip>\d+\.\d+\.\d+\.\d+)})
                    event.set("[source][ip]", sip[:ip])
                    #timestamp
                    stm = xx1&.match(%r{(?<stamp>^.+)\s\d+\.\d+\.\d+\.\d+})
                    event.set("timestampx", stm[:stamp])
                  end
                  if c == 2
                    event.set("[device][vendor]", xx1)
                  end
                  if c == 3
                    event.set("[observer][product]", xx1)
                  end
                  if c == 4
                    event.set("[device][version]", xx1)
                  end
                  if c == 5
                    event.set("[event][code]", xx1)
                  end
                  if c == 6
                    event.set("[event][name]", xx1)
                  end
                  if c == 7
                    event.set("[event][severity]", xx1)
                  end
                end
              end
#=======================================================
'}

date { match => [ "timestampx", "MMM dd HH:mm:ss", "MMM  dd HH:mm:ss" ] }
mutate { remove_field => ["timestampx", "host", "path", "part" , "type"] }

}



###############################################################################
output {
 stdout {}
 }


